# Android开发艺术探索 第11章 线程与线程池 读书笔记

主席（任玉刚）当时在他群里发这书简介的时候，只看目录就知道是我想要的，哈哈，书还是有些难度的，不过真是一本超棒的书，干货满满。

1. 主线程-&gt;界面相关；子线程-&gt;耗时操作；
<li>AsyncTask底层是线程池；IntentService/HandlerThread底层是线程；HandlerThread是具有消息循环的线程，内部可以使用handler；<br>
IntentService是一个服务，内部采用HandlerThread来执行任务，完成后会自动退出，很像后台线程，但由于是服务 存活率高</li>
1. 频繁创建销毁线程不明智，使用线程池是正确的做法

### 1.主线程和子线程

1. 主线程主要处理界面交互逻辑，由于用户随时会和界面交互，所以主线程在任何时候都需要有较高响应速度，则不能执行耗时的任务；
1. android3.0开始，网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而现ANR现象

### 2.Android的线程形态

#### 2.1 AsyncTask

<li>三个参数（都可为Void)：<br>
Params：参数<br>
Progress：执行进度<br>
Result：返回值</li>
<li>四个方法 ：<br>
onPreExecute() 主线程执行，异步方法执行前调用。<br>
doInBackground(Params...params) 线程池中执行，用于执行异步任务；在方法内部用publishProgress 来更新任务进度。<br>
onProgressUpdate(Progress...value)主线程执行，后台任务进度状态改变时被调用。<br>
onPostExecute(Result result) 主线程执行，异步任务执行之后被调用<br>
**执行顺序**： onPreExecute-&gt;doInBackground-&gt;onPostExecute 如果取消了异步任务，会回调onCancelled()，onPostExecute则不会被调用</li>

**Tips**: AsyncTask的类必须在主线程加载，Android4.1及以上已经被系统自动完成了；AsyncTask对象必须在主线程创建；execute方法需要在UI线程调用；一个AsyncTask对象只能调用一次；Android1.6之前串行执行，Android1.6采用线程池并行处理任务，Android3.0开始，采用一个线程执行任务，但也可以通过executeOnExecutor方法来并行执行任务

#### 2.2 AsyncTask的工作原理

1. AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个InternalHandler,其中线程池SerialExecutor用于任务排队，THREAD_POOL_EXECUTOR用于真正执行任务，InternalHandler用于将执行环境切换到主线程
1. AsyncTask的排队过程：系统首先会把AsyncTask的Params参数封装成FutureTask对象，它充当Runnable的作用，接下来这个FutureTask会交给SerialExecutor的execute方法处理，execute方法首先会把FutereTask对象插入到任务队列mTasks中去；如果没有正在活动的AsyncTask任务，就会执行下一个AsyncTask任务；同时当一个AsyncTask任务执行完成后，AsyncTask会继续执行其他任务直到所有任务都执行为止，可以看出默认情况，AsyncTask是串行执行的（Android3.0后）

#### 2.3 HandlerThread

- HandlerThread继承了Thread,是一种可以使用Handler的Thread；在run方法中通过looper.prepare()来开启消息循环，这样就可以在HandlerThread中创建Handler了；外界可以通过一个Handler的消息方式来通知HandlerThread来执行具体任务；确定不使用之后，可以通过quit或quitSafely方法来终止线程执行；具体使用场景是IntentService。

#### 2.4 IntentService

1. IntentSercie是一种特殊的Service,继承了Service并且是抽象类，任务执行完成后会自动停止，优先级远高于普通线程，适合执行一些高优先级的后台任务；
<li>IntentService封装了HandlerThread和Handler，onCreate方法自动创建一个HandlerThread,然后用它的Looper构造了一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息都会在HandlerThread执行；<br>
IntentServiced的onHandlerIntent方法是一个抽象方法，需要在子类实现，onHandlerIntent方法执行后，stopSelt(int startId)就会停止服务，如果存在多个后台任务，执行完最后一个stopSelf(int startId)才会停止服务</li>

### 3.Android线程池

优点：

1. 重用线程池的线程，减少线程创建和销毁带来的性能开销
1. 控制线程池的最大并发数，避免大量线程互相抢系统资源导致阻塞
1. 提供定时执行和间隔循环执行功能

#### 3.1 ThreadPoolExecutor（熟悉后可自定义线程池）

<li>
**Executor**是一个接口，线程池的具体实现在ThreadPoolExecutor；它提供了一系列的参数来配置线程池；Android的线程池 大部分都是通     过Executor提供的工厂方法创建的</li>

###### 2. ThreadPoolExecutor常见构造参数

1. corePoolSize： 线程池的核心线程数，默认情况下，核心线程会一直存活(设置了超时机制除外，  allowCoreThreadTimeOut属性为true时开启）
1. maxinmumPoolSize： 线程池能容纳的最大线程数，当活动的线程达到这个数值之后，后续新任务会被阻塞
1. keepAliveTime： 非核心线程闲置的超时时长，超过这个时长，非核心线程就会被回收,当allowCoreThreadTimeOut为true时，keepAliveTime同样作用于核心线程。
1. unit：keepAliveTime的时间单位，这是一个枚举，常用有TimeUnit.MILLISECONDS(毫秒)、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES(分钟)
1. workQueue： 线程池中的任务队列，通过execute方法提交的Runnable对象会存储在这个参数中
1. threadFactory： 线程工厂，为线程池提供创建线程的功能，是个接口，提供Thread newThread(Runnable r)方法
1. RejectedExecutionHandle：当线程池无法执行新任务时，可能由于线程队列已满或无法成功执行任务，这时候       ThreadPoolExecutor会调用handler的      rejectedExecution的方法，默认会抛出RejectedExecutionException

###### 3. ThreadPoolExecutor执行任务大致遵循如下规则:

1. 如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务
1. 如果线程池中的线程数量已经达到或超过核心线程数量，那么任务会被插入到任务队列中排队等待执行
1. 如果步骤2中无法将任务插入到任务队列中，往往是因为任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务
1. 如果步骤3中线程数量达到线程池规定的最大值，线程池会拒绝执行任务，并会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者

###### 4. `AsyncTask的THREAD_POOL_EXECUTOR`线程池配置:

1. 核心线程数等于CPU核心数+1
1. 线程池最大线程数为CPU核心数的2倍+1
1. 核心线程无超时机制，非核心线程的闲置超时时间为1秒
1. 任务队列容量是128

#### 3.2 常见的4个线程池

1. FixedThreadPool：线程数量固定的线程池，当所有线程都处于活动状态时，新任务会处于等待状态，只有核心线程并且不会回收（无超时机制），能快速的响应外界请求。
1. CachedThreadPool：线程数量不定的线程池，最大线程数为Integer.MAX_VALUE(相当于任意大),当所有线程都处于活动状态时，会创建新线程来处理任务；线程池的空闲进程超时时长为60秒，超过就会被回收；任何任务都会被立即执行，适合执行大量的耗时较少的任务。
1. ScheduledThreadPool：核心线程数量固定，非核心线程数量无限制，非核心线程闲置时会被立刻回收，用于执行定时任务和具有固定周期的重复任务。
1. SingleThreadExecutor：只有一个核心线程，所有任务都在这个线程中串行执行，不需要处理线程同步问题
